<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
    
 canvas {
    /* background-color: #ffe2c2;
    background-image: "bgd.png"; */
    /* background: url(bgd.png) 0 0, #ffe2c2 -91px 0; */
    background: url(dirt.jpg) 0 0;
    background-size: 480px 100px;
    background-position: bottom;
    background-repeat: no-repeat;
	animation: change-color-anim 30s ease-in;
} 
#imagearea a {
    width: 480px;
    height: 20px;

}
#area1 {
    top: 20px;
    left: 20px;
}

#area2 {
    top: 90px;
    left: 40px;
}

@keyframes change-color-anim {
	0.0%{
		background-color: #15102d;
	}
    12.5%{
		background-color: #2D1D7A;
	}
    25.0%{
		background-color: #573170;
	}
    37.5%{
		background-color: #804565;
	}
    50.0%{
		background-color: #AA585B;
	}
    62.5%{
		background-color: #D36C50;
	}
    75.0%{
		background-color: #FD8046;
	}
    87.5%{
		background-color: #ffbc74;
	}
    100%{
		background-color: #ffe2c2;
	}
} 

</style>
</head>
<body onload="startGame()">
    <!-- <div id = "imagearea" >
        <p id="area1"> <img src= "bgd.png"></p>
    </div> -->
<script >

var myGamePiece;
const enemies= [];
const friends= [];
var isCollidingVar;
var newFriend = false;
var enemySpeed = 1;
var loss = false;

class Background {
    constructor(gameWidth, gameHeight) {
        this.gamewidth = gamewidth;
        this.gameHeight = gameHeight;
        this.image = url(nightbg.png);
        this.x = 0;
        this.y - 0;
        this.width = 2400;
        this.height = 1648;
    }
    draw(canvas) {
        canvas.drawImage(this.image, this.x, this.y);
    }
}

function random(n) {
      return Math.floor(Math.random()*n);
}
//if the collision is true, what all needs to be updated?

function randomBetween(min, max) {
  return Math.random() * (max - min) + min;
}
// const bgd = new Background(canvas.width, canvas.height);

function startGame() {
    myGameArea.start();
    myGamePiece = new component(60, 60, "blue", 60, 200, 1);
    // var can = document.getElementById('canvas');
    // var ctx = can.getContext('2d');
    // // bgd.draw(ctx);
    setTimeout(youLose, 30000);
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = this.canvas.getContext("2d");
        // bgd.draw(ctx);

        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            myGameArea.key = e.keyCode;
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.key = false;
        })
    }, 
    clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}



function component(width, height, color, x, y) {
    this.gamearea = myGameArea;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);

    }
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;        
    }
    //this functions checks if the position of one piece overlaps with another
    this.isColliding = function(collidingBlock) {
    if (
      this.x < collidingBlock.x + collidingBlock.width &&
      this.x + this.width > collidingBlock.x &&
      this.y < collidingBlock.y + collidingBlock.height &&
      this.height + this.y > collidingBlock.y
    ) {
        //if colliding, change speed to 3 or 0.5 depending on type
       // console.log("collide = true");
        return true;
    }
        //if not colliding, keep speed at 1
     //   console.log("collide = false");
        return false;
  }   
}

function updateGameArea() {
    myGameArea.clear();
    myGamePiece.speedX = 0;
    myGamePiece.speedY = 0;    
    
    //console.log(isCollidingVar);
   

    if (myGameArea.key && myGameArea.key == 37) {myGamePiece.speedX =-3 }
    if (myGameArea.key && myGameArea.key == 39) {myGamePiece.speedX =3 }
    if (myGameArea.key && myGameArea.key == 38) {myGamePiece.speedY =-3}
    if (myGameArea.key && myGameArea.key == 40) {myGamePiece.speedY =3}
    myGamePiece.newPos();    
    myGamePiece.update();

    //make a new invader, prob inside the update function
    //friends will hold components that are friends
    if(friends.length < 4){
    friends.push(new component(30, 30, "green",
    random(480)+480, random(270)-20));
    //random(myGameArea.canvas.width), random(canvas.height)));
    }

    if(enemies.length < 4){
    enemies.push(new component(30, 30, "red",
    random(480)+480, randomBetween(200, 250)));
    //random(myGameArea.canvas.width), random(canvas.height)));
    }

    for (var i = 0; i<enemies.length; i++){
        //add logic to take away first in array if the arrau is 10+
        if (enemies[i].x < -10 ){
            enemies.splice(i, 1);
            //this is where you would add logic to gain points
        }
        if(myGamePiece.isColliding(enemies[i])){
            loss = true;
        }
        //the second cube is being marked at colliding but the value is
        //actually move each cube
        enemies[i].x -= 1;

        //update position
        enemies[i].newPos();
        enemies[i].update(); 
    } 

    for (var i = 0; i<friends.length; i++){
        //add logic to take away first in array if the the cube reaches the end
        if (friends[i].x < -10 ){
            friends.splice(i, 1);
            //this is where you would add logic to gain points
        }

        //power-up
        if(myGamePiece.isColliding(friends[i])){
          
    if (myGameArea.key && myGameArea.key == 37) {myGamePiece.speedX =-6 }
    if (myGameArea.key && myGameArea.key == 39) {myGamePiece.speedX =6 }
    if (myGameArea.key && myGameArea.key == 38) {myGamePiece.speedY =-6}
    if (myGameArea.key && myGameArea.key == 40) {myGamePiece.speedY =6}
    myGamePiece.newPos();    
    myGamePiece.update();
             console.log("green");
             myGamePiece.newPos();    
             myGamePiece.update();
        }
        //actually move each cube
        friends[i].x -= 1;

        //update position
        friends[i].newPos();
        friends[i].update(); 
    } 
    
    if(loss){youLose();clearInterval(myGameArea.interval);}
}

//endgame
function youLose() {
    alert("You Lose! Reload the page a few times to restart!");
    enemies(0,enemies.length);

    //here is where you would get a custom popup
    document.getElementById('popup').style.display = "block";
    //button to start game over
    //button to go back to home page
    document.getElementById("popupForm").style.display = "none";
    document.getElementById(
'close-btn').addEventListener('click', (e) => {
            document.getElementById(
'wrapper').style.visibility = "hidden";
            window.location.reload();
        });
}

function youWin() {
    // if the goal was touched it directs here
    //button to home page
    //button to next stage
}

function makeBgd() {
    // inside main_javascript.js
 
var can = document.getElementById('canvas1');
 
 // The 2D Context for the HTML canvas element. It
 // provides objects, methods, and properties to draw and
 // manipulate graphics on a canvas drawing surface.
 var ctx = can.getContext('2d');
  
 // canvas width and height
 can.width = 480;
 can.height = 270;
  
 // create an image element
 var img = new Image();
  
 // specify the image source relative to the html or js file
 // when the image is in the same directory as the file
 // only the file name is required:
 img.src = "nightbg.png";
  
 // window.onload is an event that occurs when all the assets
 // have been successfully loaded( in this case only the spacebg.png)
 window.onload = function() {
     // the initial image height
     var imgHeight = 0;
     var imgWidth = 0;
  
     // the scroll speed
     // an important thing to ensure here is that can.height
     // is divisible by scrollSpeed
     var scrollSpeed = 0;
   // this is the primary animation loop that is called 60 times
     // per second
 
     // #move screen from arrowkeys
 
     function loop()
     {
         // draw image 1
         
         ctx.drawImage(img, imgWidth, 0);
  
         // draw image 2
         ctx.drawImage(img, imgWidth - can.width, 0);
  
         // update image height
         imgWidth += scrollSpeed;
  
         //resetting the images when the first image entirely exits the screen
         if (imgWidth == can.width)
             imgWidth = 0;
  
         // this function creates a 60fps animation by scheduling a
         // loop function call before the
         // next redraw every time it is called
         window.requestAnimationFrame(loop);
     }
  
     // this initiates the animation by calling the loop function
     // for the first time
     loop();
 
 
     function moveLeft() {
         var left = parseInt(window.getComputedStyle(character).getPropertyValue("left"));
         if (left > -10) {
         character.style.left = left - 2 + "px";
         scrollSpeed += 2;
         }
     }
     
     function moveRight() {
         var left = parseInt(window.getComputedStyle(character).getPropertyValue("left"));
         if (left < 1000) {
         character.style.left = left + 2 + "px";
         scrollSpeed += 2;
         }
     }
     
     document.addEventListener("keydown", event => {
         if (both == 0) {
             both++;
         if (event.key == "ArrowLeft") {
             interval = setInterval(moveLeft, 1);
         }
         if (event.key == "ArrowRight") {
             interval = setInterval(moveRight, 1);
         }
     }
     });
  
 }
}

</script>
<script src="main_javascript.js"></script>
<p>use the arrow keys on you keyboard to move the square</p>

</body>
</html>
